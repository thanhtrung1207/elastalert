# -*- coding: utf-8 -*-
import logging
from email.mime.text import MIMEText
from smtplib import SMTP, SMTPException
from socket import error

from staticconf.loader import yaml_loader

from util import EAException
from util import pretty_ts
from jira.client import JIRA
from jira.exceptions import JIRAError


def get_counts_string(match):
    """ Looks for keys matching top_events_X in matches, generated by get_top_counts, and
    returns a readable string about the various counts. """
    message = ''
    for key, counts in match.items():
        if key.startswith('top_events_'):
            message += 'The following are the top %s event counts, by %s:\n' % (len(counts), key[11:])
            top_events = counts.items()
            top_events.sort(key=lambda x: x[1], reverse=True)
            for term, count in top_events:
                message += '%s: %s\n' % (term, count)
            message += '\n'
    return message


def basic_match_string(rule, match):
    """ Returns a string for the given rule and match. """
    text = rule['name'] + '\n\n'

    # Add custom alert text
    alert_text = rule.get('alert_text', '')
    text += alert_text
    while text[-2:] != '\n\n':
        text += '\n'

    if rule.get('alert_text_type') != 'alert_text_only':
        # Add rule text
        text += rule['type'].get_match_str(match)
        while text[-2:] != '\n\n':
            text += '\n'

        # Add top_counts
        if rule.get('top_count_keys'):
            text += get_counts_string(match)

        if rule.get('alert_text_type') != 'exclude_fields':
            # Add match items
            match_items = match.items()
            match_items.sort(key=lambda x: x[0])
            text += '\n'.join(['%s: %s' % (key, val) for key, val in match.items() if not key.startswith('top_events_')])

    return text


class Alerter(object):
    """ Base class for types of alerts.

    :param rule: The rule configuration.
    """
    required_options = frozenset([])

    def __init__(self, rule):
        self.rule = rule
        self.from_addr = 'ElastAlert'

    def alert(self, match):
        """ Send an alert. Match is a dictionary of information about the alert.

        :param match: A dictionary of relevant information to the alert.
        """
        raise NotImplementedError()

    def get_info(self):
        """ Returns a dictionary of data related to this alert. """
        raise NotImplementedError()


class DebugAlerter(Alerter):
    """ The debug alerter uses a Python logger (by default, alerting to terminal). """

    def alert(self, matches):
        logging.info('%d match(es)' % (len(matches)))
        qk = self.rule.get('query_key', None)
        for match in matches:
            if qk in match:
                logging.info('%s matched %s at %s' % (match[qk], self.rule['name'], match[self.rule['timestamp_field']]))
            else:
                logging.info('%s at %s' % (self.rule['name'], match[self.rule['timestamp_field']]))
            logging.info(basic_match_string(self.rule, match))

    def get_info(self):
        return {'type': 'debug'}


class EmailAlerter(Alerter):
    """ Sends an email alert """
    required_options = frozenset(['email'])

    def __init__(self, *args):
        super(EmailAlerter, self).__init__(*args)

        self.smtp_host = self.rule.get('smtp_host', 'localhost')
        # Convert email to a list if it isn't already
        if isinstance(self.rule['email'], str):
            self.rule['email'] = [self.rule['email']]

    def alert(self, matches):
        subject = 'ElastAlert: %s' % (self.rule['name'])

        # If the rule has a query_key, add that value plus timestamp to subject
        if 'query_key' in self.rule:
            qk = matches[0].get(self.rule['query_key'])
            if qk:
                subject += ' - %s' % (qk)
        body = ''

        for match in matches:

            body += basic_match_string(self.rule, match)
            # Separate text of aggregated alerts with dashes
            if len(matches) > 1:
                body += '\n----------------------------------------\n'

        email_msg = MIMEText(body)
        email_msg['Subject'] = subject
        email_msg['To'] = ', '.join(self.rule['email'])
        email_msg['Reply-To'] = self.rule.get('email_reply_to', email_msg['To'])

        try:
            self.smtp = SMTP(self.smtp_host)
        except (SMTPException, error) as e:
            raise EAException("Error connecting to SMTP host: %s" % (e))
        self.smtp.sendmail(self.from_addr, self.rule['email'], email_msg.as_string())
        self.smtp.close()

        logging.info("Sent email to %s" % (self.rule['email']))

    def get_info(self):
        return {'type': 'email',
                'recipients': self.rule['email']}


class JiraAlerter(Alerter):
    """ Creates a Jira ticket for each alert """
    required_options = frozenset(['jira_server', 'jira_account_file', 'jira_project', 'jira_issuetype'])

    def __init__(self, rule):
        super(JiraAlerter, self).__init__(rule)
        self.server = self.rule['jira_server']
        self.get_jira_account(self.rule['jira_account_file'])
        self.project = self.rule['jira_project']
        self.issue_type = self.rule['jira_issuetype']
        self.component = self.rule.get('jira_component')
        self.label = self.rule.get('jira_label')
        self.assignee = self.rule.get('jira_assignee')

        self.jira_args = {'project': {'key': self.project},
                          'issuetype': {'name': self.issue_type}}

        if self.component:
            self.jira_args['components'] = [{'name': self.component}]
        if self.label:
            self.jira_args['labels'] = [self.label]
        if self.assignee:
            self.jira_args['assignee'] = {'name': self.assignee}

        try:
            self.client = JIRA(self.server, basic_auth=(self.user, self.password))
        except JIRAError as e:
            # JIRAError may contain HTML, pass along only first 1024 chars
            raise EAException("Error connecting to JIRA: %s" % (str(e)[:1024]))

    def set_assignee(self, assignee):
        self.assignee = assignee
        if assignee:
            self.jira_args['assignee'] = {'name': assignee}
        elif 'assignee' in self.jira_args:
            self.jira_args.pop('assignee')

    def get_jira_account(self, account_file):
        """ Gets the username and password from a jira account file.

        :param account_file: Name of the file which contains user and password information.
        """
        account_conf = yaml_loader(account_file)
        if 'user' not in account_conf or 'password' not in account_conf:
            raise EAException('Jira account file must have user and password fields')
        self.user = account_conf['user']
        self.password = account_conf['password']

    def alert(self, matches):
        # If there is a query_key, use that in the title
        if 'query_key' in self.rule and self.rule['query_key'] in matches[0]:
            title = 'ElastAlert: %s matched %s' % (matches[0][self.rule['query_key']], self.rule['name'])
        else:
            title = 'ElastAlert: %s' % (self.rule['name'])
        title += ' - %s' % (pretty_ts(matches[0][self.rule['timestamp_field']], self.rule.get('use_local_time')))

        # Add count for spikes
        count = matches[0].get('spike_count')
        if count:
            title += ' - %s+ events' % (count)

        description = ''
        for match in matches:
            description += basic_match_string(self.rule, match)
            if len(matches) > 1:
                description += '\n----------------------------------------\n'

        self.jira_args['summary'] = title
        self.jira_args['description'] = description

        try:
            self.issue = self.client.create_issue(**self.jira_args)
        except JIRAError as e:
            raise EAException("Error creating JIRA ticket: %s" % (e))
        logging.info("Opened Jira ticket: %s" % (self.issue))

    def get_info(self):
        return {'type': 'jira'}
